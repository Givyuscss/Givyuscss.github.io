I"</<h2 id="关联规则">关联规则</h2>

<hr />

<ul>
  <li>
    <p><strong>关联规则基本概念</strong></p>

    <p>关联规则用来形容两个时间之间的关系:<script type="math/tex">X\mapsto Y</script></p>

    <p>关联规则有如下几个指标：</p>

    <p>支持度:<script type="math/tex">Support(X,Y)=\frac{num(XY)}{num(total)}=P(XY)</script></p>

    <p>置信度:<script type="math/tex">Confidence(X,Y)=P(X\vert Y)=\frac{P(XY)}{P(Y)}，Confidence(Y,X)=P(Y\vert X)=\frac{P(XY)}{P(X)}</script></p>

    <p>提升度:<script type="math/tex">lift(X\Leftarrow Y)=\frac{P(X\vert Y)}{X}</script></p>
  </li>
  <li>
    <p><strong>Apriori算法</strong></p>

    <p>Apriori算法是为了寻找样本中的频繁集，即支持度大于最小阈值的组合。</p>

    <p>Apriori提出两条规则：</p>
    <ol>
      <li>若一个集合是频繁集，则它的子集都是频繁集</li>
      <li>若一个集合不是频繁集，则它的超集都不是频繁集</li>
    </ol>

    <p>Apriori算法步骤：
  针对记录T:</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">TID</th>
          <th style="text-align: center">Items</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T1</td>
          <td style="text-align: center">l1,l3,l4</td>
        </tr>
        <tr>
          <td style="text-align: center">T2</td>
          <td style="text-align: center">l2,l3,l5</td>
        </tr>
        <tr>
          <td style="text-align: center">T3</td>
          <td style="text-align: center">l1,l2,l3,l5</td>
        </tr>
        <tr>
          <td style="text-align: center">T4</td>
          <td style="text-align: center">l2,l5</td>
        </tr>
      </tbody>
    </table>

    <ol>
      <li>首先扫描所有的事物，对记录中每个项进行计数得到候选项集记为<script type="math/tex">C1</script>。</li>
    </ol>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">项集</th>
          <th style="text-align: center">支持度计数</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">{l1}</td>
          <td style="text-align: center">2</td>
        </tr>
        <tr>
          <td style="text-align: center">{l2}</td>
          <td style="text-align: center">3</td>
        </tr>
        <tr>
          <td style="text-align: center">{l3}</td>
          <td style="text-align: center">3</td>
        </tr>
        <tr>
          <td style="text-align: center">{l4}</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: center">{l5}</td>
          <td style="text-align: center">3</td>
        </tr>
      </tbody>
    </table>

    <ol>
      <li>对支持度计数和支持度的阈值进行比较，剔除小于支持度阈值的项集，得出频繁1项集记作<script type="math/tex">L1</script>。(假设阈值为2)</li>
    </ol>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">项集</th>
          <th style="text-align: center">支持度计数</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">{l1}</td>
          <td style="text-align: center">2</td>
        </tr>
        <tr>
          <td style="text-align: center">{l2}</td>
          <td style="text-align: center">3</td>
        </tr>
        <tr>
          <td style="text-align: center">{l3}</td>
          <td style="text-align: center">3</td>
        </tr>
        <tr>
          <td style="text-align: center">{l5}</td>
          <td style="text-align: center">3</td>
        </tr>
      </tbody>
    </table>

    <ol>
      <li>使用连接来产生候选项集2项集。剪掉项集中包含不频繁项的项集。剔除支持度计数小于阈值的项，得出频繁2项集<script type="math/tex">L2</script>。</li>
    </ol>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">项集</th>
          <th style="text-align: center">支持度计数</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">{l1,l3}</td>
          <td style="text-align: center">2</td>
        </tr>
        <tr>
          <td style="text-align: center">{l2,l3}</td>
          <td style="text-align: center">2</td>
        </tr>
        <tr>
          <td style="text-align: center">{l2,l5}</td>
          <td style="text-align: center">3</td>
        </tr>
        <tr>
          <td style="text-align: center">{l3,l5}</td>
          <td style="text-align: center">2</td>
        </tr>
      </tbody>
    </table>

    <ol>
      <li>重复2、3步直到下一个候选集为空。</li>
      <li>得出所有的频繁项集。</li>
    </ol>
  </li>
  <li>
    <p><strong>FP-Growth算法</strong>
  对于大型的数据集，Apriori的计算速度显然过于太慢，FP-Groth只需遍历数据集两边，相比于Apriori速度得到了很大的提升。</p>

    <p><strong>算法流程</strong></p>

    <ol>
      <li>遍历数据集，得到频繁项为1的项目集，定义最小支持度，删除小于最小支持度的项目，将条目按项目集中的频次降序进行排列。</li>
      <li>再次，创建项头表，以及FP树。</li>
      <li>于找到每个项目条件模式基,递归调用树结构，删除小于最小支持度的项。如果最终呈现单一路径的树结构，则直接列举所有组合；非单一路径的则继续调用树结构，直到形成单一路径即可。</li>
    </ol>

    <p><strong>示例</strong></p>

    <p>数据清单为：</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">Tid</th>
          <th style="text-align: center">Items</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">1</td>
          <td style="text-align: center">I1, I2, I5</td>
        </tr>
        <tr>
          <td style="text-align: center">2</td>
          <td style="text-align: center">I2, I4</td>
        </tr>
        <tr>
          <td style="text-align: center">3</td>
          <td style="text-align: center">I2, I3</td>
        </tr>
        <tr>
          <td style="text-align: center">4</td>
          <td style="text-align: center">I1, I2, I4</td>
        </tr>
        <tr>
          <td style="text-align: center">5</td>
          <td style="text-align: center">I1, I3</td>
        </tr>
        <tr>
          <td style="text-align: center">6</td>
          <td style="text-align: center">I2, I3</td>
        </tr>
        <tr>
          <td style="text-align: center">7</td>
          <td style="text-align: center">I1, I3</td>
        </tr>
        <tr>
          <td style="text-align: center">8</td>
          <td style="text-align: center">I1, I2, I3, I5</td>
        </tr>
        <tr>
          <td style="text-align: center">9</td>
          <td style="text-align: center">I1, I2, I3</td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>
        <p>构建FP树</p>

        <p>a. 遍历数据集，物品进行计数</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: center">I1</th>
              <th style="text-align: center">I2</th>
              <th style="text-align: center">I3</th>
              <th style="text-align: center">I4</th>
              <th style="text-align: center">I5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">6</td>
              <td style="text-align: center">7</td>
              <td style="text-align: center">6</td>
              <td style="text-align: center">2</td>
              <td style="text-align: center">2</td>
            </tr>
          </tbody>
        </table>

        <p>b. 设定最小支持度为2，降序排列物品表</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: center">I2</th>
              <th style="text-align: center">I1</th>
              <th style="text-align: center">I3</th>
              <th style="text-align: center">I4</th>
              <th style="text-align: center">I5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">7</td>
              <td style="text-align: center">6</td>
              <td style="text-align: center">6</td>
              <td style="text-align: center">2</td>
              <td style="text-align: center">2</td>
            </tr>
          </tbody>
        </table>

        <p>c. 根据物品出现次数调整清单</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: center">Tid</th>
              <th style="text-align: center">Items</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">1</td>
              <td style="text-align: center">I2, I1, I5</td>
            </tr>
            <tr>
              <td style="text-align: center">2</td>
              <td style="text-align: center">I2, I4</td>
            </tr>
            <tr>
              <td style="text-align: center">3</td>
              <td style="text-align: center">I2, I3</td>
            </tr>
            <tr>
              <td style="text-align: center">4</td>
              <td style="text-align: center">I2, I1, I4</td>
            </tr>
            <tr>
              <td style="text-align: center">5</td>
              <td style="text-align: center">I1, I3</td>
            </tr>
            <tr>
              <td style="text-align: center">6</td>
              <td style="text-align: center">I2, I3</td>
            </tr>
            <tr>
              <td style="text-align: center">7</td>
              <td style="text-align: center">I1, I3</td>
            </tr>
            <tr>
              <td style="text-align: center">8</td>
              <td style="text-align: center">I2, I1, I3, I5</td>
            </tr>
            <tr>
              <td style="text-align: center">9</td>
              <td style="text-align: center">I2, I1, I3</td>
            </tr>
          </tbody>
        </table>

        <p>d. 构建FP树</p>

        <p>加入清单，出现相同的节点则进行累加。由于所有清单的物品顺序都是从高到低的，因此靠前的物品都更靠近树根。</p>
      </li>
    </ul>

    <p><img src="/img/in-post/FP-Growth/1.png" width="400px" height="300px" /></p>

    <ul>
      <li>
        <p>挖掘频繁集</p>

        <p>对于每一个元素项，获取其对应的条件模式基。条件模式基是以所查找元素项为结尾的路径集合。每一条路径其实都是一条前缀路径。按照从下往上的顺序，考虑两个例子。</p>

        <p>（1）考虑I5，得到条件模式基{(I2 I1:1), (I2 I1 I3)}, 然后递归调用FP-growth，模式后缀为I5。这个条件FP树是单路径的，在FP-growth中直接列举{I2:2，I1:2，I3:1}的所有组合，之后和模式后缀I5取并集得到支持度大于2的所有模式：{ I2 I5:2, I1 I5:2, I2 I1 I5:2}。</p>

        <p><img src="/img/in-post/FP-Growth/2.png" width="400px" height="300px" /></p>

        <p>（2）考虑I3，I3的条件模式基是{(I2 I1:2), (I2:2), (I1:2)}，然后递归调用FP-growth，模式前缀为I3。I3的条件FP树是一个多路径树，首先把模式后缀I3和条件FP树中的项头表中的每一项取并集，得到一组模式{I2 I3:4, I1 I3:4}，但是这一组不是后缀为I3的所有模式。还需要递归调用FP-growth，模式后缀为{I1，I3}，{I1，I3}的条件模式基为{I2：2}。这是一个单路径的条件FP-树，在FP-growth中把I2和模式后缀{I1，I3}取并得到模式{I1 I2 I3：2}。最终模式后缀I3的支持度大于2的所有模式为：{ I2 I3:4, I1 I3:4, I1 I2 I3:2}</p>
      </li>
    </ul>

    <p><img src="/img/in-post/FP-Growth/3.png" width="400px" height="300px" /></p>
  </li>
</ul>
:ET